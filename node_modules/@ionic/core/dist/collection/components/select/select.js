import { CssClassMap, EventEmitter } from '@stencil/core';
import { HTMLIonSelectOptionElementEvent } from '../select-option/select-option';
import { BlurEvent, FocusEvent, SelectInputChangeEvent } from '../../utils/input-interfaces';
import { ActionSheet, ActionSheetButton, ActionSheetOptions } from '../action-sheet/action-sheet';
import { Alert, AlertOptions } from '../alert/alert';
import { Popover, PopoverOptions } from '../popover/popover';
import { ActionSheetController } from '../action-sheet-controller/action-sheet-controller';
import { AlertController } from '../alert-controller/alert-controller';
import { PopoverController } from '../popover-controller/popover-controller';
import { SelectPopoverOption } from '../select-popover/select-popover';
export class Select {
    constructor() {
        this.childOpts = [];
        this.isExpanded = false;
        /**
         * If true, the user cannot interact with the select. Defaults to `false`.
         */
        this.disabled = false;
        /**
         * The text to display on the cancel button. Default: `Cancel`.
         */
        this.cancelText = 'Cancel';
        /**
         * The text to display on the ok button. Default: `OK`.
         */
        this.okText = 'OK';
        /**
         * The interface the select should use: `action-sheet`, `popover` or `alert`. Default: `alert`.
         */
        this.interface = 'alert';
        /**
         * Any additional options that the `alert`, `action-sheet` or `popover` interface
         * can take. See the [AlertController API docs](../../alert/AlertController/#create), the
         * [ActionSheetController API docs](../../action-sheet/ActionSheetController/#create) and the
         * [PopoverController API docs](../../popover/PopoverController/#create) for the
         * create options for each interface.
         */
        this.interfaceOptions = {};
        this.selectId = 'ion-sel-' + (selectIds++);
    }
    valueChanged() {
        // this select value just changed
        // double check the select option with this value is checked
        if (this.value === undefined) {
            // set to undefined
            // ensure all that are checked become unchecked
            this.childOpts.filter(o => o.selected).forEach(selectOption => {
                selectOption.selected = false;
            });
            this.text = '';
        }
        else {
            let hasChecked = false;
            const texts = [];
            this.childOpts.forEach(selectOption => {
                if ((Array.isArray(this.value) && this.value.indexOf(selectOption.value) > -1) || (selectOption.value === this.value)) {
                    if (!selectOption.selected && (this.multiple || !hasChecked)) {
                        // correct value for this select option
                        // but this select option isn't checked yet
                        // and we haven't found a checked yet
                        // so CHECK IT!
                        selectOption.selected = true;
                    }
                    else if (!this.multiple && hasChecked && selectOption.selected) {
                        // somehow we've got multiple select options
                        // with the same value, but only one can be checked
                        selectOption.selected = false;
                    }
                    // remember we've got a checked select option button now
                    hasChecked = true;
                }
                else if (selectOption.selected) {
                    // this select option doesn't have the correct value
                    // and it's also checked, so let's uncheck it
                    selectOption.selected = false;
                }
                if (selectOption.selected) {
                    texts.push(selectOption.textContent);
                }
            });
            this.text = texts.join(', ');
        }
        // emit the new value
        this.ionChange.emit({
            value: this.value,
            text: this.text
        });
    }
    optLoad(ev) {
        const selectOption = ev.target;
        this.childOpts.push(selectOption);
        if (this.value !== undefined && selectOption.value === this.value) {
            // this select has a value and this
            // radio equals the correct select value
            // so let's check this select option
            selectOption.selected = true;
        }
        else if (this.value === undefined && selectOption.selected) {
            // this select does not have a value
            // but this selection option is checked, so let's set the
            // select's value from the checked select option
            this.value = selectOption.value;
        }
        else if (selectOption.selected) {
            // if it doesn't match one of the above cases, but the
            // select option is still checked, then we need to uncheck it
            selectOption.selected = false;
        }
    }
    optUnload(ev) {
        const index = this.childOpts.indexOf(ev.target);
        if (index > -1) {
            this.childOpts.splice(index, 1);
        }
    }
    onSelect(ev) {
        // ionSelect only come from the checked select option
        this.childOpts.forEach(selectOption => {
            if (selectOption === ev.target) {
                this.value = selectOption.value;
            }
            else {
                selectOption.selected = false;
            }
        });
    }
    componentWillLoad() {
        if (!this.value) {
            this.value = this.multiple ? [] : undefined;
        }
        this.name = this.name || this.selectId;
    }
    componentDidLoad() {
        const label = this.getLabel();
        if (label) {
            this.labelId = label.id = this.name + '-lbl';
        }
        if (this.multiple) {
            // there are no values set at this point
            // so check to see who should be selected
            const checked = this.childOpts.filter(o => o.selected);
            this.value.length = 0;
            checked.forEach(o => {
                // doing this instead of map() so we don't
                // fire off an unecessary change event
                this.value.push(o.value);
            });
            this.text = checked.map(o => o.textContent).join(', ');
        }
        else {
            const checked = this.childOpts.find(o => o.selected);
            if (checked) {
                this.value = checked.value;
                this.text = checked.textContent;
            }
        }
    }
    getLabel() {
        const item = this.el.closest('ion-item');
        if (item) {
            return item.querySelector('ion-label');
        }
        return null;
    }
    open(ev) {
        let selectInterface = this.interface;
        if ((selectInterface === 'action-sheet' || selectInterface === 'popover') && this.multiple) {
            console.warn('Select interface cannot be "' + selectInterface + '" with a multi-value select. Using the "alert" interface instead.');
            selectInterface = 'alert';
        }
        if (selectInterface === 'popover' && !ev) {
            console.warn('Select interface cannot be a "popover" without passing an event. Using the "alert" interface instead.');
            selectInterface = 'alert';
        }
        if (selectInterface === 'popover') {
            return this.openPopover(ev);
        }
        if (selectInterface === 'action-sheet') {
            return this.openActionSheet();
        }
        return this.openAlert();
    }
    openPopover(ev) {
        const popoverOpts = {
            component: 'ion-select-popover',
            data: {
                value: this.value,
                options: this.childOpts.map(o => {
                    return {
                        text: o.textContent,
                        value: o.value,
                        checked: o.selected,
                        disabled: o.disabled,
                        handler: () => {
                            this.value = o.value;
                            this.close();
                        }
                    };
                })
            },
            cssClass: 'select-popover ' + (this.interfaceOptions.cssClass ? ' ' + this.interfaceOptions.cssClass : ''),
            ev: ev
        };
        const popover = this.popoverCtrl.create(popoverOpts);
        return popover.then(overlay => {
            this.overlay = overlay;
            return overlay.present().then(() => {
                this.isExpanded = true;
                return overlay;
            });
        });
    }
    openActionSheet() {
        const actionSheetButtons = this.childOpts.map(option => {
            return {
                role: (option.selected ? 'selected' : ''),
                text: option.textContent,
                handler: () => {
                    this.value = option.value;
                }
            };
        });
        actionSheetButtons.push({
            text: this.cancelText,
            role: 'cancel',
            handler: () => {
                this.ionCancel.emit(this);
            }
        });
        const actionSheetOpts = {
            buttons: actionSheetButtons,
            cssClass: 'select-action-sheet' + (this.interfaceOptions.cssClass ? ' ' + this.interfaceOptions.cssClass : '')
        };
        const actionSheet = this.actionSheetCtrl.create(actionSheetOpts);
        return actionSheet.then(overlay => {
            this.overlay = overlay;
            return overlay.present().then(() => {
                this.isExpanded = true;
                return overlay;
            });
        });
    }
    openAlert() {
        const label = this.getLabel();
        let labelText = null;
        if (label) {
            labelText = label.textContent;
        }
        const alertOpts = {
            title: labelText,
            inputs: this.childOpts.map(o => {
                return {
                    type: (this.multiple ? 'checkbox' : 'radio'),
                    label: o.textContent,
                    value: o.value,
                    checked: o.selected,
                    disabled: o.disabled
                };
            }),
            buttons: [
                {
                    text: this.cancelText,
                    role: 'cancel',
                    handler: () => {
                        this.ionCancel.emit(this);
                    }
                },
                {
                    text: this.okText,
                    handler: (selectedValues) => {
                        this.value = selectedValues;
                    }
                }
            ],
            cssClass: 'select-alert ' +
                (this.multiple ? 'multiple-select-alert' : 'single-select-alert') +
                (this.interfaceOptions.cssClass ? ' ' + this.interfaceOptions.cssClass : '')
        };
        const alert = this.alertCtrl.create(alertOpts);
        return alert.then(overlay => {
            this.overlay = overlay;
            return overlay.present().then(() => {
                this.isExpanded = true;
                return overlay;
            });
        });
    }
    /**
     * Close the select interface.
     */
    close() {
        // TODO check !this.overlay || !this.isFocus()
        if (!this.overlay) {
            return Promise.resolve();
        }
        const overlay = this.overlay;
        this.overlay = null;
        this.isExpanded = false;
        return overlay.dismiss();
    }
    onKeyUp() {
        this.keyFocus = true;
    }
    onFocus() {
        this.ionFocus.emit();
    }
    onBlur() {
        this.keyFocus = false;
        this.ionBlur.emit();
    }
    hostData() {
        return {
            class: {
                'select-disabled': this.disabled,
                'select-key': this.keyFocus
            }
        };
    }
    render() {
        let addPlaceholderClass = false;
        let selectText = this.selectedText || this.text;
        if (!selectText && this.placeholder) {
            selectText = this.placeholder;
            addPlaceholderClass = true;
        }
        const selectTextClasses = {
            'select-text': true,
            'select-placeholder': addPlaceholderClass
        };
        return [
            h("div", { role: 'textbox', "aria-multiline": 'false', class: selectTextClasses }, selectText),
            h("div", { class: 'select-icon', role: 'presentation' },
                h("div", { class: 'select-icon-inner' })),
            h("button", { role: 'combobox', "aria-haspopup": 'dialog', "aria-expanded": this.isExpanded, "aria-labelledby": this.labelId, "aria-disabled": this.disabled ? 'true' : false, onClick: this.open.bind(this), onKeyUp: this.onKeyUp.bind(this), onFocus: this.onFocus.bind(this), onBlur: this.onBlur.bind(this), class: 'item-cover' },
                h("slot", null)),
            h("input", { type: 'hidden', name: this.name, value: this.value })
        ];
    }
}
let selectIds = 0;
